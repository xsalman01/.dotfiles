#!/bin/bash

# post-merge hook to automatically comment/uncomment branch-specific configurations
# Extended to handle noctalia/settings.json (avatar, wallpaper.directory, bar.monitors).

# Get current branch (target branch)
TARGET_BRANCH=$(git branch --show-current)

# Only run if merging into 'main' or 'laptop'
if [[ "$TARGET_BRANCH" != "main" && "$TARGET_BRANCH" != "laptop" ]]; then
    exit 0
fi

# Determine action based on target branch
if [[ "$TARGET_BRANCH" == "main" ]]; then
    ACTION="enable_desktop"
else
    ACTION="enable_laptop"
fi

# Check jq availability (needed for JSON edits)
if command -v jq >/dev/null 2>&1; then
    JQ_OK=1
else
    JQ_OK=0
    echo "WARNING: 'jq' not found in PATH â€” JSON edits will be skipped."
fi

# List of files to process (same as in your .gitattributes)
FILES=(
    ".zprofile"
    "i3/autostart.i3config"
    "i3/audio.i3config"
    "i3/gaps.i3config"
    "hypr/hyprland.conf"
    "hypr/modules/workspaces.conf"
    "hypr/modules/looks.conf"
    "hypr/modules/audio_controls.conf"
    "rofi/config.rasi"
    "rofi/applications/spotify-polybar.desktop"
    "polybar/modules/tray.ini"
    "polybar/modules/volume.ini"
    "kitty/kitty.conf"
    "noctalia/settings.json"
)

# Process each file
for file in "${FILES[@]}"; do
    # Skip if file doesn't exist
    [ -f "$file" ] || continue

    echo "Processing $file for branch $TARGET_BRANCH"

    # Special handling for noctalia/settings.json
    if [[ "$file" == "noctalia/settings.json" ]]; then
        if [[ $JQ_OK -ne 1 ]]; then
            echo "  -> Skipping JSON edits for $file because jq is missing."
            continue
        fi

        if [[ "$ACTION" == "enable_desktop" ]]; then
            echo "  -> Applying desktop profile (dopeman + HDMI-A-1, DVI-I-1, compact)"
            jq '
              .general.avatarImage |= gsub("/home/[^/]+/"; "/home/dopeman/") |
              .wallpaper.directory |= gsub("/home/[^/]+/"; "/home/dopeman/") |
              .bar.monitors = ["HDMI-A-1", "DVI-I-1"] |
              .bar.density = "mini"
            ' "$file" > "$file.tmp" && mv "$file.tmp" "$file" || {
                echo "  -> ERROR: failed to write $file"
            }
        else
            echo "  -> Applying laptop profile (Agnosia + HDMI-A-1, eDP-1, default)"
            jq '
              .general.avatarImage |= gsub("/home/[^/]+/"; "/home/Agnosia/") |
              .wallpaper.directory |= gsub("/home/[^/]+/"; "/home/Agnosia/") |
              .bar.monitors = ["HDMI-A-1", "eDP-1"] |
              .bar.density = "compact"
            ' "$file" > "$file.tmp" && mv "$file.tmp" "$file" || {
                echo "  -> ERROR: failed to write $file"
            }
        fi

        # done with this file
        continue
    fi

    # Determine comment character based on file extension (JSON already handled)
    case "$file" in
        *.rasi)        COMMENT="//" ;;
        *.kdl)         COMMENT="//" ;;
        *)             COMMENT="#"  ;;
    esac

    # Process the file (comment/uncomment blocks)
    awk -v action="$ACTION" -v comment="$COMMENT" '
        /### DESKTOP START ###/ { in_desktop = 1; print; next }
        /### DESKTOP END ###/   { in_desktop = 0; print; next }
        /### LAPTOP START ###/  { in_laptop  = 1; print; next }
        /### LAPTOP END ###/    { in_laptop  = 0; print; next }

        {
            if (in_desktop) {
                if (action == "enable_desktop") {
                    # Uncomment desktop lines
                    sub("^" comment "[ ]?", "", $0)
                } else {
                    # Comment desktop lines
                    if ($0 !~ "^" comment) $0 = comment " " $0
                }
            }
            else if (in_laptop) {
                if (action == "enable_laptop") {
                    # Uncomment laptop lines
                    sub("^" comment "[ ]?", "", $0)
                } else {
                    # Comment laptop lines
                    if ($0 !~ "^" comment) $0 = comment " " $0
                }
            }
            print
        }
    ' "$file" > "$file.tmp" && mv "$file.tmp" "$file"
done

exit 0

